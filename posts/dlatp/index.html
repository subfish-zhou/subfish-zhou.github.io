<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Introduction of Deep Learning for Automatic Theorem Proving | Subfish&#39;s Blog</title>
<meta name="keywords" content="DL, Lean, ATP" />
<meta name="description" content="DL4ATP">
<meta name="author" content="Subfish">
<link rel="canonical" href="https://subfish-zhou.github.io/posts/dlatp/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.48a18943c2fc15c38a372b8dde1f5e5dc0bc64fa6cb90f5a817d2f8c76b7f3ae.css" integrity="sha256-SKGJQ8L8FcOKNyuN3h9eXcC8ZPpsuQ9agX0vjHa3864=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://subfish-zhou.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://subfish-zhou.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://subfish-zhou.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://subfish-zhou.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://subfish-zhou.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Introduction of Deep Learning for Automatic Theorem Proving" />
<meta property="og:description" content="DL4ATP" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://subfish-zhou.github.io/posts/dlatp/" /><meta property="og:image" content="https://subfish-zhou.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-20T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2022-03-20T00:00:00&#43;00:00" />


<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://subfish-zhou.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="Introduction of Deep Learning for Automatic Theorem Proving"/>
<meta name="twitter:description" content="DL4ATP"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://subfish-zhou.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Introduction of Deep Learning for Automatic Theorem Proving",
      "item": "https://subfish-zhou.github.io/posts/dlatp/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Introduction of Deep Learning for Automatic Theorem Proving",
  "name": "Introduction of Deep Learning for Automatic Theorem Proving",
  "description": "DL4ATP",
  "keywords": [
    "DL", "Lean", "ATP"
  ],
  "articleBody": "Introduction of Deep Learning for Automatic Theorem Proving Basic mathematics is finally waiting for a day when it can be computer-aided to massively increase productivity. In recent years, the field of automatic theorem proving (ATP) has generated an amazing amount of work through the introduction of deep learning and reinforcement learning, especially with the rapid progress of Large language models (LLM). Although we are still a little far away from having computers prove big propositions like the Riemann conjecture on their own, we can already talk predictably about how automatic theorem proving will help human mathematicians do their job. This paper pays tribute to the influential @Peng Keyao “Introduction to Computer-Aided Proof”. The formal mathematical language introduced in this paper is also the theoretical background of this paper. Modern ATP system is basically carried out on the basis of formal language. It is also shown as tactic in Lean or hammer in Isabelle, so it is suggested that readers who have not read this article should refer to it first.\nThis article focuses on the current progress in automatic theorem proving with deep learning and reinforcement learning (abbreviated DL+ATP below, but note that RL is also key). DL+ATP is developing rapidly, but I don’t want this article to be out of date, so I won’t cover too much technical content, and I will keep up with the field with another review that will be updated continuously. The purpose of this article is to present ideas, implications, clarify misconceptions, and answer doubts, with the aim of exposing this new, vibrant and significant field to enthusiasts and researchers in mathematics, computing, and beyond.\nThis article begins with the following questions (but the answers are intertwined, so the table of contents is not organized there) :\nWhy theorems can be proved automatically;\nHow DL+ATP works;\nWhat achievements have been made in the field of automatic proof;\nWhat mathematicians hope to gain from automatic proof;\nWhat are the effects of automatic theorem proving;\nBeginners how to get started with DL+ATP.\nHere are some of the results so far: As of the writing time of this paper on July 1, 2023.1, the most representative and influential DL+ATP work HyperTree Proof Search for Neural Theorem Proving (2022.5.23, see Meta Blog, paper, HTPS), automatically solved 10 International Mathematical Olympiades (IMO) problems, such as one of them:\n（IMO1964p1_2）7 can’ t divide $2^n+1$ exactly.\nThe formal expression of this problem in Lean and the automatic proof process given by AI are as follows:\nimport data.nat.prime\rtheorem imo_1964_p1_2 (n : ℕ) :\r¬ 7 ∣ (2 ^ n + 1) :=\rbegin\rrw nat.dvd_iff_mod_eq_zero,\rrewrite [nat.add_mod, nat.mod_eq_of_lt],\robviously,\rapply nat.strong_induction_on n,\rinduction n,\r{\rintros n IH,\rcases n,\rnorm_num,\rcases n,\rnorm_num,\rrw [nat.succ_eq_add_one, pow_succ],\rrw [nat.succ_eq_add_one, pow_succ],\rinduction n,\rnorm_num,\rrw [nat.succ_eq_add_one, pow_succ],\rnorm_num [nat.mul_mod, ←mul_assoc],\rcontrapose! IH,\rrefine ⟨n_n, nat.lt_succ_iff.mpr _, IH⟩,\rexact nat.le_succ_of_le (nat.le_succ _),\r},\rexact n_ih,\rend This automatically generated proof (after a lot of simplification) translates into natural language roughly as follows:\nThe original problem is equivalent to $2^n+ the remainder of $1 divided by 7 is not equal to 0, so either $2^n divided by the remainder of 7 plus the remainder of 1 divided by 7 is not equal to 0, which is obvious, or $2^n divided by the remainder of 7 plus the remainder of 1 divided by 7 is less than 7. This proposition is proved by strong induction ∀(n :ℕ),(∀(m :ℕ),m \u003c n → 2 ^ m % 7 + 1 \u003c 7) → 2 ^ n % 7 + 1 \u003c 7 inductive 1)∀ (m : ℕ), m \u003c 0 → 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ 0 % 7 + 1 \u003c 7 : obviously 2)∀ (m : ℕ), m \u003c n + 1 → 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ (n + 1) % 7 + 1 \u003c 7 inductive 1.0) ∀ (m : ℕ), m \u003c 1 → 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ 1 % 7 + 1 \u003c 7 : obviously 1.1) ∀ (m : ℕ), m \u003c n + 1 + 1 → 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ (n + 1 + 1) % 7 + 1 \u003c 7 inductive 1.1.0) ∀ (m : ℕ), m \u003c 1 + 1 → 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ (1 + 1)% 7 + 1 \u003c 7 : obviously 1.1.1) ∀ (m : ℕ), m \u003c n + 1 + 1 + 1→ 2 ^ m % 7 + 1 \u003c 7 pf. 2 ^ (n + 1 + 1 + 1) % 7 + 1 \u003c 7 So far, 2 ^ (n + 1 + 1 + 1) % 7 + 1 = 8 * 2 ^ n % 7 + 1 = (7 + 1) * 2 ^ n % 7 + 1 = 2 ^ n % 7 + 1, obviously.\nIf we look closely, we will find that this proof through extremely violent, with a strong mechanical wind means, in fact, also in disguised realization of the human proof “first observed” this “fantastic idea” (TL; DR, mainly reflected in the last step). It should be pointed out that this proof is not generated by a fixed algorithm of symbolism, such as SAT or Wu method, but is indeed actively searched out in the proof tree by thinking in a similar way to human mathematicians (algorithmic ideas will be briefly introduced in the following article). However, although the principle of this algorithm is close to human thinking, the result of this proof is really not like human writing, tedious and unelegant, mathematicians may feel that the rice bowl is still secure after reading. But this result also makes us reflect that we may indeed have come to the moment when we can discuss AI automatic theorem proving, although the “observation” of this problem is relatively simple, slightly trained students can master, but is the “art” of the theorem proving considered more profound really a kind of unattainable light of human wisdom, which is not allowed to be touched by AI?\nNote: You may have heard of LeanDojo (the work of the new intelligent Yuan scam), but the paper does not see that it is more powerful than Hypertree. We’ll talk about that later.\n自动证明是如何可能的 Automatic theorem proving is one of the earliest and most traditional problems in artificial intelligence, as far back as 1954, Martin Davis developed the first theorem proving program, proving that “the sum of two even numbers is even”; The Logic theorist program presented by Allen Newell and Herbert Simon at the Immortal Dartmouth Conference in 1956 proved more than half the theorems in Russell and Whitehead’s Principia Mathematica, and some were even more concise than the authors’ proofs. Thus the school of symbols was founded. The influence of these early works on computer science is numerous, such as formal verification, expert systems and knowledge graphs are its descendants, and even the study of the SAT opened the discipline of computational complexity. The pinnacle of the symbolist line was the Vampire program, which is still being updated today and continues to play a role in areas such as formal verification. However, for the original goal of automatic proof of mathematical theorems, the symbolist route is inevitably limited by combinatorial explosion, so it can not be applied to the practice of mathematicians for a long time. In the statistical learning era, support vector machines and other models have been used to construct heuristics for proof search, but the results are not good. In recent years, with the addition of tools such as deep learning to automatic theorem proving, we finally have the hope that deep learning can develop heuristics good enough to overcome the combinatorial explosion and even achieve theorem proving algorithms that are close to the way humans think.\nBefore we look at how DL+ATP is possible, let’s look at how proof is structured as a computational task. There is no need to deal with the writing of successive calculus in proof theory, and we can ignore the concrete rules of calculus such as the resolution principle, and just from the most abstract task structure, we can think of the proof as a search tree. In analogy to the game of Go, each step has a number of points to choose, and eventually there will be several paths leading to victory, theorem proving can also be seen as in each propositional state (in the proof theory and ITP system, the states are context and goal) can apply a number of theorems or proof skills to the current state, so as to make it become the next state. And eventually there will be several paths leading to the completion of the proof. We use an example to show how search trees and the simplest heuristics work: the proof that “sqrt(2) is irrational”. If the reader is familiar with how ITP systems like Lean work, this example may be better understood.\nGiven this proposition, we have several options, for example, we can try induction and find that the proposition contains nothing that can be induced, so there is no way to perform induction. So maybe we can try proof by contradiction? Then we find that the proof by contradiction does change the state of the problem, and after restoring the definition back (that is, rewriting the definition in Lean) we get a new proposition “There are m,n, m,n mutual primes and sqrt(2)=m/n” and the goal becomes the derivation contradiction. Then there will be many choices, such as “both sides of the equation can be +1 at the same time” to apply, or “both sides of the equation can be multiplied by 2” to apply, or “both sides of the equation can be squared at the same time” to apply. If we don’t know the answer in advance, there are actually an infinite number of choices, that is, the search tree is infinitely wide. (In Lean, we have a lot of alternative tactics and theorems that can be rw) At this time, we have begun to see the “combinatorial explosion”, and the automatic proof algorithm cannot go through so many theorems, so some heuristics are needed to help select the next search branch. For example, you can use the number of symbols contained in the proposition to define a “proposition complexity”, and try to prevent the complexity of the proposition from rising when searching. In this way, the algorithm may give up trying to “+1 on both sides” because it makes the proposition more complicated. A less naive and more targeted heuristic at the moment might be “familiarity with symbols”, such as when the algorithm finds that it knows very little about sqrt, that only a few theorems can deal with it, and that more theorems can deal with integers and rational numbers, then it will tend to find a way to eliminate SQRT, at the moment using “squares of both sides”. Thus we (skipping a step) turn the original statement into “There are m,n, m,n mutual primes and 2=m²/n²”. Then the algorithm decides that it might not be that familiar with fractions, so it multiplies n² again, so the heuristic may stop there, and the algorithm will consider other search techniques.\nDue to Godel’s incompleteness theorem, Tarski’s first-order real numbers are decidable, but the super-exponential algorithm, and the NPC property of SAT, it can be argued that there is no “ultimate heuristic” that can guide all proofs, and Wu’s method that can completely solve elementary geometric problems is only a few special cases. In a general problem a heuristic can only be applied to a very narrow set of problem patterns. Theorem-prover in the era of symbolism is a big competition of heuristics, whose heuristic design is more delicate, who can better coordinate multiple heuristics, who can achieve better performance. But math problems are so varied that, even after decades of hard work, these provers are prohibitive about high school math, let alone keeping up with modern math.\nIn fact, other areas of AI have encountered similar situations, such as image recognition, which also relies on humans to manually design features, but performance on the Imagenet dataset has been hovering around 50%. In 2014, deep learning was born and instantly changed the face of the image recognition field, and now deep learning has also begun to emerge in the field of theorem proving.\nWhy is all this possible? You may feel that symbolic heuristic design may be in line with some human ideas in some cases, but it does not capture the most crucial part of human mathematical practice: humans have gone through a considerable amount of mathematical training, accumulated a lot of experience, and sometimes these experiences are difficult to describe, “I don’t know how I came up with it, but I just thought of it.” Deep learning can precisely allow the algorithm to accumulate experience, when it has done many many problems, when it encounters a new problem, it will recall whether it has seen a similar “problem type”, and find a similar practice with the training at that time.\nWe can use Monte Carlo search trees to describe a statistically enhanced theorem proving model. The Monte Carlo search tree gives a probability for each branch, such as 0.9 for “proof by contradiction”, 0.09 for “induction”, and 0.01 for some branches. The search is prioritized by probability, which avoids traversing all branches. In the symbolist era, in fact, the combined action of multiple heuristics would also use this model, but under a fixed combination of symbolic heuristics, the probability is usually fixed, but now we can adjust these probabilities through training (this is actually a reinforcement learning technique), For example, after searching for a branch with 0.9 probability, the algorithm finds that the descendants of this branch cannot successfully prove the theorem, indicating that the algorithm is wrong in estimating the success of this method, and then it will appropriately reduce this probability to avoid repeating the mistake (only reduce rather than completely kill it). The descendants of this branch may not be completely traversed and therefore it is not entirely certain that it is not possible). The HTPS algorithm introduced at the beginning of this article goes a step further on this idea, and it finds that people will have relatively fixed problem-solving routines when they encounter some problem types, that is, a series of theorem application steps may appear repeatedly, and only a few parameters may change according to specific circumstances. It then packages these routines into trees that become alternatives at each search step, eliminating the need to search one by one for theorems to be applied next. This “tree on tree” idea is the origin of “Hypertree”.\nThe probabilistic feedback mechanism of the Monte Carlo search tree alone is not enough, because the tree is too large (infinite), most of the solutions can not be found, so it is necessary to accumulate experience from training through deep neural networks, which are given a good enough initial probability in the Monte Carlo tree model. What deep learning does best is capture features, such as features of cats and dogs in images, or features common to English and Chinese. In the most abstract sense, analytical theorems are more likely to be proved analytically, and algebraic theorems are more likely to be solved with algebraic tools. Even if algebraic theorems are really proved analytically, we can also feel some “analytical flavor” in them. These are actually a kind of restriction on the direction of search. Deep neural networks can “accumulate experience” by discovering the features of proposition or proof process in the data, and adopting the corresponding proof process when encountering propositions with similar characteristics.\nFeatures in different task data often have their own uniqueness, and we can better extract them by designing networks with different structures accordingly. For example, we use convolutional neural networks to capture features in images. So what kind of deep neural network should we design to extract the features in the proof? Some earlier work had treated proofs as sequences or graphs, and accordingly used RNNS or GNNS to process them, but with little success. The recent success of large language models has led us to think of proofs as a language, and to use language models to capture features. The GPT-f family of work represented by HTPS uses a language model similar to GPT2, while the more recent LeanDojo uses a T5 model. The details of how these language models work and how different language models differ in proving theorems are outside the topic of this article. Readers are free to inquire for their own information, which will be covered in a technical overview later in this article.\nBut we also see that training theorem proving on LLM is not good enough. Part of LeanDojo’s work shows that GPT4 cannot prove complex mathematical theorems such as Stirling’s formula, even with sufficient prompt. The reason may be that there are too few theorem-proof data, and the most suitable method of LLM training has not been found, resulting in the lack of full use of LLM capabilities; It is also possible that the task of theorem proving itself has a richer complex and fine structure than language, and the violent aesthetics of LLM are not enough to conquer the arduous task of theorem proving. But while the task is daunting, it is not as mysterious as it was a few decades ago, and the mechanisms of proof and even reasoning have accumulated a wealth of knowledge, but there is still a lot of work to be done.\nThis section concludes with a response to some common questions:\nBecause of Godel’s incompleteness theorem (or for some other reason), a machine can never prove a mathematical theorem, because people are not bound by Godel’s theorem, so theorem proving can only be done by people.\nResponse: Godel actually has this view himself. But this view implies that man is an oracle Turing machine, that is, a Turing machine that can run for an infinite amount of time, and can travel through time to inform the present moment of the results of its operation after an infinite amount of time. According to the Church-Turing thesis, the Oracle is not a computational model that can be implemented in our universe. Corresponding to the task of proving theorems, this means that one can go through all the possibilities and find the right theorems to apply to without wasting time. It seems that human “inspiration” has a similar quality, but it actually means that one can find a proof without mathematical training, just by dreaming of a fairy. I prefer to believe that inspiration comes from some specific computational mechanism, even though it is currently only incompletely described by theories such as deep learning and reinforcement learning.\nBut people can write axiom systems such as ZFC, they can also know that these axiom systems are not complete and then add axioms, they also invented the Turing machine and know that the Turing machine cannot solve the halting problem, people can set the foundation for mathematical proofs and Turing machines, and the machine itself has no way to set the foundation for itself.\nResponse: This is to describe the level at which one can work on a metalinguistic level, that is, we study the properties of another language by virtue of language and only by virtue of language. A metalanguage is also a language, subject to the rules of computation, and presenting an axiomatic system and a halting problem is no different from other Turing-computable problems. Besides, people can’t solve the shutdown problem. There is no reason to think that Turing machines cannot observe themselves, just as modern computers can also check their own memory for errors, it is simply engineering.\nPresent and future of DL+ATP In December 2021, a paper titled “Advancing mathematics by guiding human intuition with AI” was published in Nature, It tells the story of Deepmind researchers who used traditional algorithms such as clustering to refine some laws in knot theory and representation theory, helping human mathematicians prove two new theorems. In June 2023, Tao evaluated how language models such as GPT4 helped him in his mathematical research, such as helping him quickly extract the content of other people’s papers. AI is popping up in and out of mathematics, helping mathematicians with all sorts of work, but AI writing its own mathematical proofs seems a long way off. On the one hand, mathematics itself is very complex, and on the other hand, it is limited by the lack of data. Humans do write many papers and textbooks, accumulate a large amount of mathematical corpus, and LLMS do train on mathematical corpus such as Wikipedia. If you ask ChatGPT about math, it can answer a lot of valuable information, but interestingly, when you ask it to prove a theorem it has never seen before, it will output sentences that look like math but are full of errors, as if a writer who doesn’t know math is trying to create lines for a mathematician character. Deep learning is good at capturing features, but it can’t use propositions and verify the correctness of propositions, so it can only “look” like mathematics rather than actually implement mathematics. There is actually no machine that can verify the correctness of natural language mathematical proofs, and sometimes not even humans themselves, because every now and then there are papers that no human being can understand. At present, only formal languages such as Metamath, Isabella, Coq, and Lean can be used as the basic data for AI to understand mathematics, because they can be compiled and run to verify correctness.\nIn 1973, Andrzej Trybulec developed Mizar, the first formal language specifically for mathematics, as well as an associated mathematics library, in order to verify the correctness of his doctoral thesis (although fifty years later, we have not been able to realize his ideal). This theorem library is still under maintenance and has accumulated 1w+ definitions 65k+ theorems. There are still ATP algorithms tested on Mizar. In recent years, type theory languages such as Coq and Lean have built larger theorem libraries, which have become more and more popular, and test question libraries such as MiniF2F (F2F is short for formal to formal) have been established to measure the performance of ATP algorithms. MiniF2F contains 488 questions described in four formal languages (Coq, Lean, Isabelle, Hol light, but Hol light only contains 330 questions) and natural language, collected from various mathematical competitions, including many questions from the famous mathematical Odyssey IMO. For example, the question shown at the top of the article. The researchers also launched the IMO Grand Challenge, hoping to bring AI to the IMO gold medal.\n(There is a hole to fill here, Mizar is very readable, very natural language like, and there is a recent rewritten version of Rust, I don’t know why it hasn’t caught on like Coq or Lean, wait for anyone who meets Mizar group to ask) The original motivation for mathematicians to develop formal languages was to test proofs programmatically and mechanically, but perhaps the most profound change this tool brought to the study of mathematics was that it clearly divided the study of mathematics into two parts: the form, the strict statement that defines the theorem and the calculus of the proof; And ideas, that is, why the definition theorem is written the way it is, why a proposition is used in a proof. Ideas are the most mysterious and confusing things in mathematics, excellent ideas are often named genius, and even regarded as miracles, ordinary people can only admire, let alone use scientific means to study and reproduce these ideas. Category theory, for example, may be one of those attempts that belongs to mathematicians. Now we have the tools of cognitive science and the theory of artificial intelligence, and as the first section shows, the laws of mathematical ideas are being revealed step by step. In order to more clearly demonstrate the dichotomy between form and idea in mathematics, I have been thinking of an experimental project to write a complete mathematics textbook in a formal language. What can be written in formal language is all formalized, and there must be something left that must be written in natural language, and these are the parts of the idea. These natural languages can be a great source of research for ideas.\nThe most pressing problem facing DL+ATP research is that mathematical propositions expressed in formal language are still a drop in the ocean compared to the entire mathematical edifion of mankind. Fortunately, the development of LLM technology has led to “pre-training” and “fine-tuning” tools that can circumvent the lack of data to some extent. The idea is that many of the abilities and knowledge reflected in the data are universal, such as reasoning ability; The ability required for a particular task may be specialized, such as the specific syntax of a formal language. If the LLM has a general knowledge of the language before learning the domain-specific task, it is much better than the traditional method of directly letting the AI do the specific task from random initialization. Specifically, ATP, natural language mathematics, and formal language mathematics express the same mathematical meaning despite their differences in rigor and grammar, so the LLM pre-trained on a large number of human mathematical languages, learned some mathematical knowledge first, and then specialized in fine-tuning the scarce formal languages, should have a much better effect than only learning on formal language data. The classic work of DL+ATP, GPT-f, is to pretrain GPT3 on the natural language data set CommonCrawl, 23GB of Github code, 10GB of Arxiv Math papers, and 2GB of Math StackExchange forum articles. The motivation for training on code is that code also reflects human reasoning, much like proof. However, the subsequent improvement work of GPT-f HTPS believes that it is better to only pre-train on Arxiv, and who can say the configuration of optimized performance in engineering. HTPS has achieved a pass rate of 58.6% on the verification set and 41.0% on the test set of Lean language MiniF2F, which is the best result of pure proof search relying only on formal language. More information on evaluating data sets and algorithm performance can be found on the PaperWithCode page, but the information on this page is incomplete and has not been maintained for a long time.\nNote 1: One of the drawbacks of fine-tuning is that it causes the LLM to focus only on domain-specific tasks and forget about general tasks, so it cannot be mathematically fine-tuned by tools such as ChatGPT to give it strong mathematical capabilities, which would make it lose other capabilities. Mathematical data sets were already part of ChatGPT’s pre-training, although the pre-training data did not give it enough mathematical power. Although LLMS can be pre-trained to learn mathematics beyond the available theorem proof data, the lack of theorem proof data is always a major hindrance to advancing the field. Readers who have the experience of using formal language will have a deep understanding that the process of mathematical proof in formal language is much more difficult than that of writing proof in natural language. Many details that we usually think are very ordinary and natural need to be completed, so the establishment of formal language theorem library needs a lot of human labor. If writing a formal language is such a hassle, why not let AI do it? The first attempt was made in 2018, followed by a report by Christian Szegedy in 2020, which formally raised the issue of autoformalization, the automatic translation of natural language mathematical propositions and proofs into formal language, like machine translation. The best performance of automated formalization tasks to date is also achieved by LLM, with a May 2022 test reporting that the best programming language model, Codex, could correctly translate 38 problems from natural language to Isabelle out of 150 problems extracted from the MATH dataset (which contains 12,500 natural language expressed math problems). It can be imagined that an algorithm that can translate two different mathematical languages well will inevitably involve an understanding of the nature of mathematical semantics, so the study of automatic formalization will also feed into the study of proof.\nIn terms of the concrete realization of the two problems, automatic formalization and ATP are also complementary tasks, because natural language proof is full of leaps, these natural omissions for humans can not be handled in the formal system, then ATP can be used to automatically complete. In turn, there is a clever practical idea that since formal language data is scarce, the search process for ATP can also be guided by natural language propositions. Representative work in this direction is the 2022 Draft, sketch, and prove: Guiding formal theorem provers with informal proofs (DSP), which uses Codex on Isabelle language to map natural language proofs into formal language proofs “draft”, that is, there are some leap-forward formal proofs. These hops are then automatically completed with Isabelle’s symbolic autoprover Sledgehammer (Isabelle’s symbolic autoprover is much stronger than Lean’s). The natural language proofs could have been written by a human expert, who achieved 39.3% test set accuracy, or they could have been produced by another large model of natural language mathematical questions, Minerva, which achieved 38.9% test set accuracy. If Minerva is used, then both the natural language template and the formal language proof are produced by the algorithm itself, which can also be seen as the algorithm itself doing the ATP task. the best subsequent results from this method came from Decomposing the Enigma: Subgoal-based Demonstration Learning for Formal Theorem Proving, which is an improvement of DSP, also achieves 45.5% accuracy of the test set on Isabelle, which is also the best result on MiniF2F dataset. However, it is based on a different formal language from HTPS, and relies on natural language and cannot be directly indexed.\nNote: One possible challenge to the DSP is that the Minerva training data contains mathematical text collected on the web page and the Arxiv text, which does not necessarily exclude the MiniF2F questions and is not “clean” enough, but the large language model can be regarded as a compression of the data, and generally cannot “recite” the solution, but can be regarded as a re-generated solution. However, Microsoft Copilot has done a job of reproducing irrelevant program comments, and the LLM’s internal data processing principles are still harder to understand. These results are far from ideal, but they have now translated some ATP tools that mathematicians may not think they can use. 22 years LEAN-GPTF as a proof tactic in Lean open test for a period of time, can prove some simple theorems, now closed test. HTPS has been integrated into Lean’s VSCode editor extension, and when you write a proof you click a button to get the next sentence of a dozen AI recommendations, most of which are wrong, but some are right. VSCode’s Copilot programming assistant can occasionally translate natural language math statements you write into Coq or Lean, and ChatGPT can occasionally write correct formal language proofs. The current situation looks bleak, but remember that this direction has only begun to develop in the last two or three years.\nIf you are willing to give a few more years of patience, what will DL+ATP bring to the world? The most immediate is to accelerate the development of formal mathematics. Introduction to Computer-Aided Proofs shows us a reliable and fair picture of mathematical research, and ATP can greatly reduce the cost of realizing this vision. We can feed a human math paper or a student’s answer to a test question into an automated formal algorithm, and then have it generate code to verify correctness. Alternatively, you can translate the code into human language to make it easier to read, or extract concise ideas from complex proofs to help you understand them. We may not be able to make ATP system prove some big theorems for a long time, but it is very likely to assist in the process of human thinking about mathematics, for example, an important possibility is the auxiliary retrieval of mathematical content: An idea came to my mind, and I wondered if anyone else had come up with a similar idea, maybe there was a precise theorem that expressed the idea in a way that traditional keyword matching searches could not find, but AI could understand the idea at an abstract semantic level to find relevant data.\nFinally, a little sci-fi fantasy. If one day mathematical AI can prove the Riemann conjecture, it is not difficult to imagine that AI can also solve scientific problems such as room-temperature superconductivity, controlled nuclear fusion, eliminate various diseases, and even solve all social production problems. Mathematics represents the peak of human abstract reasoning ability, and when AI also has abstract reasoning ability, it may be able to become the complete general artificial intelligence. What will society look like then?\nLearning Map If you are an enthusiast who wants to learn more about this field, with the goal of generally reading the leading papers in this direction, then you will need some introduction to deep learning and a preliminary understanding of LLM, at least familiar with the principles of the encoder-decoder architecture. It is more important to have experience with at least one formal language, and I recommend Lean here because modern DL+ATP is increasingly using Lean.\nIf you want to pursue research in this field…… Dissuade warning! You’re dealing with the most complex and comprehensive field in AI and the second most distant from money after people who do theory. (If any friend is not satisfied, please contact me to help ATP improve the ranking, thank x in advance)\nDSP instructor Albert Jiang pointed out that DL4Math people have a lot of money. HTPS writers Guillaume, Tim, Thibault, Marie-Anne went to mistral ai, Google’s Yuhuai Wu, Christian went to xai, jesse founded morph, stanislas founded dust, markus is starting a business. But I refuse to admit it until someone gives me money (x). The first is the need for more comprehensive knowledge of deep learning and reinforcement learning. LLM Needless to say, the main paradigm today is based on LLM, but CV knowledge is also helpful, because geometric propositions and the geometric intuitions of some propositions also need to be taken into account; Graph-based approaches have potential, so an understanding of GNN-related approaches can also be helpful; The latest work even uses the popular Diffusion method. In addition to these modern techniques, as seen before, DL and RL are still developed under the framework built in the pre-deep learning era, so it is important to understand the traditional methods. Outside of AI, you’ll be working on the basis of a type theory language, so you’ll need to know some “common sense”, such as mathematical logic and various type theories, functional programming, category theory, and so on. Some subproblems with a strong symbolic tradition will emphasize this knowledge more, but work like HTPS will use it as background knowledge. Overall, the road ahead for ATP is not clear, and the accumulated knowledge in this field is not deep enough to get started quickly, but researchers must have a fairly wide range of knowledge to find the next breakthrough, although they may not be directly applicable, but can provide more insight or at least not cause you to make a simple mistake.\nThe main event in the field of DL+ATP is the Artificial Intelligence and Theorem Proving conference AITP, and the Intelligent Computer Mathematics Conference CICM is also noteworthy. In addition, the MATH-AI workshop has been held in ICLR2021 and NeurIPS2022 for two sessions, and the third session will be held in NeurIPS2023 at the end of this year (2023.12.15/16). Welcome to your attention. At the NeurIPS conference, Albert Jiang, Kaiyu Yang and Emily First will also provide tutorial on machine learning theorem proving. Welcome to join us! In addition to conferences, if you’re in the Lean zulip community, check out stream Machine-Learning-for-Theorem Proving.\nFinally, post a list of papers for further study.\nA survey of deep learning for mathematical reasoning (2022). An overview is always the best place to start.\nHolophrasm: a neural automated theorem prover for higher-order logic (2016). DL+ATP started with quite advanced ideas, and there was even no transformer at that time. Unfortunately, the author has retired now.\nGenerative language modeling for automated theorem proving (2020). The famous GPT-f OpenAI is in with a lot of money.\nProof artifact co-training for theorem proving with language models (2021). Another classic work PACT, which uses a new training method and is more robust than GPT-f, is the main control group for future work.\nFormal mathematics statement curriculum learning (2022). The highlight is the use of curriculum learning, which is stronger than PACT.\nHypertree proof search for neural theorem proving (2022). The strongest HTPS, GPT-f scale +Holophrasm search algorithm. OpenAI’s big money turned around to hit ChatGPT, Meta took over OpenAI, but it’s not open source.\nDT-Solver: Automated Theorem Proving with Dynamic-Tree Sampling Guided by Proof-level Value Function (2023). The latest achievement, produced by Sun Yat-sen University, Peking University and Huawei. Slightly better than PACT.\nLeanDojo: Theorem Proving with Retrieval-Augmented Language Models (2023). I do not want to list it, but this article has been on the public number for a long time, in fact, the main work is to establish a data set. The structure of the model proposed in the paper is simple, and the Reprover model feels like a matching validation of the data set.\nThere are also Skip-tree Training, TacticToe, LISA and other equally wonderful jobs.\nThe above is the most basic ATP work using pure formal language, and there are more natural language components below.\nThor: Wielding hammers to integrate language models and automated theorem provers (2022) This is Thor, Go beyond PACT by having a language model that is not fine-tuned on a formal language dataset work with the formal language editor’s automatic search function.\nSolving quantitative reasoning problems with language models (2022). This is Minerva, natural language math, and even physics and chemistry.\nDraft, sketch, and prove: Guiding formal theorem provers with informal proofs (2022). This is DSP, using natural language proofs to guide the standard work of formal language proofs, going beyond Thor.\nDecomposing the Enigma: Subgoal-based Demonstration Learning for Formal Theorem Proving (2023). in this paper, the Subgoal method of reinforcement learning is introduced, and the optimal result on MiniF2F is achieved by using Diffusion on the graph to optimize in context learning.\nAutoformalization with large language models (2022). This article is enough for the direction of pure breed automatic formalization, and for early research you can check the Related Work section of this article.\nEvaluating Language Models for Mathematics through Interactions (2023). A detailed survey report on the mathematical ability of ChatGPT class large language models.\nThis list is extensive, interested friends can follow the guide in the above articles. There may be a lot of important work I can’t think of right now, please add in the comments section.\n",
  "wordCount" : "6558",
  "inLanguage": "en",
  "datePublished": "2022-03-20T00:00:00Z",
  "dateModified": "2022-03-20T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Subfish"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://subfish-zhou.github.io/posts/dlatp/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Subfish's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://subfish-zhou.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://subfish-zhou.github.io/" accesskey="h" title="Subfish&#39;s Blog (Alt + H)">Subfish&#39;s Blog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://subfish-zhou.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://subfish-zhou.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://subfish-zhou.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://subfish-zhou.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://subfish-zhou.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://subfish-zhou.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      Introduction of Deep Learning for Automatic Theorem Proving
    </h1>
    <div class="post-meta"><span title='2022-03-20 00:00:00 +0000 UTC'>March 20, 2022</span>&nbsp;·&nbsp;31 min&nbsp;·&nbsp;Subfish

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#introduction-of-deep-learning-for-automatic-theorem-proving" aria-label="Introduction of Deep Learning for Automatic Theorem Proving">Introduction of Deep Learning for Automatic Theorem Proving</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e5%8a%a8%e8%af%81%e6%98%8e%e6%98%af%e5%a6%82%e4%bd%95%e5%8f%af%e8%83%bd%e7%9a%84" aria-label="自动证明是如何可能的">自动证明是如何可能的</a></li></ul>
                </li>
                <li>
                    <a href="#present-and-future-of-dlatp" aria-label="Present and future of DL&#43;ATP">Present and future of DL+ATP</a></li>
                <li>
                    <a href="#learning-map" aria-label="Learning Map">Learning Map</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="introduction-of-deep-learning-for-automatic-theorem-proving">Introduction of Deep Learning for Automatic Theorem Proving<a hidden class="anchor" aria-hidden="true" href="#introduction-of-deep-learning-for-automatic-theorem-proving">#</a></h1>
<p>Basic mathematics is finally waiting for a day when it can be computer-aided to massively increase productivity. In recent years, the field of automatic theorem proving (ATP) has generated an amazing amount of work through the introduction of deep learning and reinforcement learning, especially with the rapid progress of Large language models (LLM). Although we are still a little far away from having computers prove big propositions like the Riemann conjecture on their own, we can already talk predictably about how automatic theorem proving will help human mathematicians do their job. This paper pays tribute to the influential @Peng Keyao &ldquo;Introduction to Computer-Aided Proof&rdquo;. The formal mathematical language introduced in this paper is also the theoretical background of this paper. Modern ATP system is basically carried out on the basis of formal language. It is also shown as tactic in Lean or hammer in Isabelle, so it is suggested that readers who have not read this article should refer to it first.</p>
<p>This article focuses on the current progress in automatic theorem proving with deep learning and reinforcement learning (abbreviated DL+ATP below, but note that RL is also key). DL+ATP is developing rapidly, but I don&rsquo;t want this article to be out of date, so I won&rsquo;t cover too much technical content, and I will keep up with the field with another review that will be updated continuously. The purpose of this article is to present ideas, implications, clarify misconceptions, and answer doubts, with the aim of exposing this new, vibrant and significant field to enthusiasts and researchers in mathematics, computing, and beyond.</p>
<p>This article begins with the following questions (but the answers are intertwined, so the table of contents is not organized there) :</p>
<ol>
<li>
<p>Why theorems can be proved automatically;</p>
</li>
<li>
<p>How DL+ATP works;</p>
</li>
<li>
<p>What achievements have been made in the field of automatic proof;</p>
</li>
<li>
<p>What mathematicians hope to gain from automatic proof;</p>
</li>
<li>
<p>What are the effects of automatic theorem proving;</p>
</li>
<li>
<p>Beginners how to get started with DL+ATP.</p>
</li>
</ol>
<p>Here are some of the results so far: As of the writing time of this paper on July 1, 2023.1, the most representative and influential DL+ATP work HyperTree Proof Search for Neural Theorem Proving (2022.5.23, see Meta Blog, paper, HTPS), automatically solved 10 International Mathematical Olympiades (IMO) problems, such as one of them:</p>
<blockquote>
<p>（IMO1964p1_2）7 can&rsquo; t divide $2^n+1$ exactly.</p>
</blockquote>
<p>The formal expression of this problem in Lean and the automatic proof process given by AI are as follows:</p>
<pre tabindex="0"><code class="language-lean" data-lang="lean">import data.nat.prime
theorem imo_1964_p1_2 (n : ℕ) :
  ¬ 7 ∣ (2 ^ n + 1) :=
begin
  rw nat.dvd_iff_mod_eq_zero,
  rewrite [nat.add_mod, nat.mod_eq_of_lt],
  obviously,
  apply nat.strong_induction_on n,
  induction n,
  {
    intros n IH,
    cases n,
    norm_num,
    cases n,
    norm_num,
    rw [nat.succ_eq_add_one, pow_succ],
    rw [nat.succ_eq_add_one, pow_succ],
    induction n,
    norm_num,
    rw [nat.succ_eq_add_one, pow_succ],
    norm_num [nat.mul_mod, ←mul_assoc],
    contrapose! IH,
    refine ⟨n_n, nat.lt_succ_iff.mpr _, IH⟩,
    exact nat.le_succ_of_le (nat.le_succ _),
  },
  exact n_ih,
end
</code></pre><p>This automatically generated proof (after a lot of simplification) translates into natural language roughly as follows:</p>
<blockquote>
<p>The original problem is equivalent to $2^n+ the remainder of $1 divided by 7 is not equal to 0, so either $2^n divided by the remainder of 7 plus the remainder of 1 divided by 7 is not equal to 0, which is obvious, or $2^n divided by the remainder of 7 plus the remainder of 1 divided by 7 is less than 7. This proposition is proved by strong induction
∀(n :ℕ),(∀(m :ℕ),m &lt; n → 2 ^ m % 7 + 1 &lt; 7) → 2 ^ n % 7 + 1 &lt; 7
inductive
1)∀ (m : ℕ), m &lt; 0 → 2 ^ m % 7 + 1 &lt; 7 pf.  2 ^ 0 % 7 + 1 &lt; 7 : obviously
2)∀ (m : ℕ), m &lt; n + 1 → 2 ^ m % 7 + 1 &lt; 7 pf. 2 ^ (n + 1) % 7 + 1 &lt; 7
inductive
1.0) ∀ (m : ℕ), m &lt; 1 → 2 ^ m % 7 + 1 &lt; 7 pf.  2 ^ 1 % 7 + 1 &lt; 7 : obviously
1.1) ∀ (m : ℕ), m &lt; n + 1 + 1 → 2 ^ m % 7 + 1 &lt; 7 pf. 2 ^ (n + 1 + 1) % 7 + 1 &lt; 7
inductive
1.1.0) ∀ (m : ℕ), m &lt; 1 + 1 → 2 ^ m % 7 + 1 &lt; 7 pf.  2 ^ (1 + 1)% 7 + 1 &lt; 7 : obviously
1.1.1) ∀ (m : ℕ), m &lt; n + 1 + 1 + 1→ 2 ^ m % 7 + 1 &lt; 7 pf. 2 ^ (n + 1 + 1 + 1) % 7 + 1 &lt; 7
So far, 2 ^ (n + 1 + 1 + 1) % 7 + 1  = 8 * 2 ^ n % 7 + 1 = (7 + 1) * 2 ^ n % 7 + 1 = 2 ^ n % 7 + 1, obviously.</p>
</blockquote>
<p>If we look closely, we will find that this proof through extremely violent, with a strong mechanical wind means, in fact, also in disguised realization of the human proof &ldquo;first observed&rdquo; this &ldquo;fantastic idea&rdquo; (TL; DR, mainly reflected in the last step). It should be pointed out that this proof is not generated by a fixed algorithm of symbolism, such as SAT or Wu method, but is indeed actively searched out in the proof tree by thinking in a similar way to human mathematicians (algorithmic ideas will be briefly introduced in the following article). However, although the principle of this algorithm is close to human thinking, the result of this proof is really not like human writing, tedious and unelegant, mathematicians may feel that the rice bowl is still secure after reading. But this result also makes us reflect that we may indeed have come to the moment when we can discuss AI automatic theorem proving, although the &ldquo;observation&rdquo; of this problem is relatively simple, slightly trained students can master, but is the &ldquo;art&rdquo; of the theorem proving considered more profound really a kind of unattainable light of human wisdom, which is not allowed to be touched by AI?</p>
<p>Note: You may have heard of LeanDojo (the work of the new intelligent Yuan scam), but the paper does not see that it is more powerful than Hypertree. We&rsquo;ll talk about that later.</p>
<h2 id="自动证明是如何可能的">自动证明是如何可能的<a hidden class="anchor" aria-hidden="true" href="#自动证明是如何可能的">#</a></h2>
<p>Automatic theorem proving is one of the earliest and most traditional problems in artificial intelligence, as far back as 1954, Martin Davis developed the first theorem proving program, proving that &ldquo;the sum of two even numbers is even&rdquo;; The Logic theorist program presented by Allen Newell and Herbert Simon at the Immortal Dartmouth Conference in 1956 proved more than half the theorems in Russell and Whitehead&rsquo;s Principia Mathematica, and some were even more concise than the authors&rsquo; proofs. Thus the school of symbols was founded. The influence of these early works on computer science is numerous, such as formal verification, expert systems and knowledge graphs are its descendants, and even the study of the SAT opened the discipline of computational complexity. The pinnacle of the symbolist line was the Vampire program, which is still being updated today and continues to play a role in areas such as formal verification. However, for the original goal of automatic proof of mathematical theorems, the symbolist route is inevitably limited by combinatorial explosion, so it can not be applied to the practice of mathematicians for a long time. In the statistical learning era, support vector machines and other models have been used to construct heuristics for proof search, but the results are not good. In recent years, with the addition of tools such as deep learning to automatic theorem proving, we finally have the hope that deep learning can develop heuristics good enough to overcome the combinatorial explosion and even achieve theorem proving algorithms that are close to the way humans think.</p>
<p>Before we look at how DL+ATP is possible, let&rsquo;s look at how proof is structured as a computational task. There is no need to deal with the writing of successive calculus in proof theory, and we can ignore the concrete rules of calculus such as the resolution principle, and just from the most abstract task structure, we can think of the proof as a search tree. In analogy to the game of Go, each step has a number of points to choose, and eventually there will be several paths leading to victory, theorem proving can also be seen as in each propositional state (in the proof theory and ITP system, the states are context and goal) can apply a number of theorems or proof skills to the current state, so as to make it become the next state. And eventually there will be several paths leading to the completion of the proof. We use an example to show how search trees and the simplest heuristics work: the proof that &ldquo;sqrt(2) is irrational&rdquo;. If the reader is familiar with how ITP systems like Lean work, this example may be better understood.</p>
<p>Given this proposition, we have several options, for example, we can try induction and find that the proposition contains nothing that can be induced, so there is no way to perform induction. So maybe we can try proof by contradiction? Then we find that the proof by contradiction does change the state of the problem, and after restoring the definition back (that is, rewriting the definition in Lean) we get a new proposition &ldquo;There are m,n, m,n mutual primes and sqrt(2)=m/n&rdquo; and the goal becomes the derivation contradiction. Then there will be many choices, such as &ldquo;both sides of the equation can be +1 at the same time&rdquo; to apply, or &ldquo;both sides of the equation can be multiplied by 2&rdquo; to apply, or &ldquo;both sides of the equation can be squared at the same time&rdquo; to apply. If we don&rsquo;t know the answer in advance, there are actually an infinite number of choices, that is, the search tree is infinitely wide. (In Lean, we have a lot of alternative tactics and theorems that can be rw) At this time, we have begun to see the &ldquo;combinatorial explosion&rdquo;, and the automatic proof algorithm cannot go through so many theorems, so some heuristics are needed to help select the next search branch. For example, you can use the number of symbols contained in the proposition to define a &ldquo;proposition complexity&rdquo;, and try to prevent the complexity of the proposition from rising when searching. In this way, the algorithm may give up trying to &ldquo;+1 on both sides&rdquo; because it makes the proposition more complicated. A less naive and more targeted heuristic at the moment might be &ldquo;familiarity with symbols&rdquo;, such as when the algorithm finds that it knows very little about sqrt, that only a few theorems can deal with it, and that more theorems can deal with integers and rational numbers, then it will tend to find a way to eliminate SQRT, at the moment using &ldquo;squares of both sides&rdquo;. Thus we (skipping a step) turn the original statement into &ldquo;There are m,n, m,n mutual primes and 2=m²/n²&rdquo;. Then the algorithm decides that it might not be that familiar with fractions, so it multiplies n² again, so the heuristic may stop there, and the algorithm will consider other search techniques.</p>
<p>Due to Godel&rsquo;s incompleteness theorem, Tarski&rsquo;s first-order real numbers are decidable, but the super-exponential algorithm, and the NPC property of SAT, it can be argued that there is no &ldquo;ultimate heuristic&rdquo; that can guide all proofs, and Wu&rsquo;s method that can completely solve elementary geometric problems is only a few special cases. In a general problem a heuristic can only be applied to a very narrow set of problem patterns. Theorem-prover in the era of symbolism is a big competition of heuristics, whose heuristic design is more delicate, who can better coordinate multiple heuristics, who can achieve better performance. But math problems are so varied that, even after decades of hard work, these provers are prohibitive about high school math, let alone keeping up with modern math.</p>
<p>In fact, other areas of AI have encountered similar situations, such as image recognition, which also relies on humans to manually design features, but performance on the Imagenet dataset has been hovering around 50%. In 2014, deep learning was born and instantly changed the face of the image recognition field, and now deep learning has also begun to emerge in the field of theorem proving.</p>
<p>Why is all this possible? You may feel that symbolic heuristic design may be in line with some human ideas in some cases, but it does not capture the most crucial part of human mathematical practice: humans have gone through a considerable amount of mathematical training, accumulated a lot of experience, and sometimes these experiences are difficult to describe, &ldquo;I don&rsquo;t know how I came up with it, but I just thought of it.&rdquo; Deep learning can precisely allow the algorithm to accumulate experience, when it has done many many problems, when it encounters a new problem, it will recall whether it has seen a similar &ldquo;problem type&rdquo;, and find a similar practice with the training at that time.</p>
<p>We can use Monte Carlo search trees to describe a statistically enhanced theorem proving model. The Monte Carlo search tree gives a probability for each branch, such as 0.9 for &ldquo;proof by contradiction&rdquo;, 0.09 for &ldquo;induction&rdquo;, and 0.01 for some branches. The search is prioritized by probability, which avoids traversing all branches. In the symbolist era, in fact, the combined action of multiple heuristics would also use this model, but under a fixed combination of symbolic heuristics, the probability is usually fixed, but now we can adjust these probabilities through training (this is actually a reinforcement learning technique), For example, after searching for a branch with 0.9 probability, the algorithm finds that the descendants of this branch cannot successfully prove the theorem, indicating that the algorithm is wrong in estimating the success of this method, and then it will appropriately reduce this probability to avoid repeating the mistake (only reduce rather than completely kill it). The descendants of this branch may not be completely traversed and therefore it is not entirely certain that it is not possible). The HTPS algorithm introduced at the beginning of this article goes a step further on this idea, and it finds that people will have relatively fixed problem-solving routines when they encounter some problem types, that is, a series of theorem application steps may appear repeatedly, and only a few parameters may change according to specific circumstances. It then packages these routines into trees that become alternatives at each search step, eliminating the need to search one by one for theorems to be applied next. This &ldquo;tree on tree&rdquo; idea is the origin of &ldquo;Hypertree&rdquo;.</p>
<p>The probabilistic feedback mechanism of the Monte Carlo search tree alone is not enough, because the tree is too large (infinite), most of the solutions can not be found, so it is necessary to accumulate experience from training through deep neural networks, which are given a good enough initial probability in the Monte Carlo tree model. What deep learning does best is capture features, such as features of cats and dogs in images, or features common to English and Chinese. In the most abstract sense, analytical theorems are more likely to be proved analytically, and algebraic theorems are more likely to be solved with algebraic tools. Even if algebraic theorems are really proved analytically, we can also feel some &ldquo;analytical flavor&rdquo; in them. These are actually a kind of restriction on the direction of search. Deep neural networks can &ldquo;accumulate experience&rdquo; by discovering the features of proposition or proof process in the data, and adopting the corresponding proof process when encountering propositions with similar characteristics.</p>
<p>Features in different task data often have their own uniqueness, and we can better extract them by designing networks with different structures accordingly. For example, we use convolutional neural networks to capture features in images. So what kind of deep neural network should we design to extract the features in the proof? Some earlier work had treated proofs as sequences or graphs, and accordingly used RNNS or GNNS to process them, but with little success. The recent success of large language models has led us to think of proofs as a language, and to use language models to capture features. The GPT-f family of work represented by HTPS uses a language model similar to GPT2, while the more recent LeanDojo uses a T5 model. The details of how these language models work and how different language models differ in proving theorems are outside the topic of this article. Readers are free to inquire for their own information, which will be covered in a technical overview later in this article.</p>
<p>But we also see that training theorem proving on LLM is not good enough. Part of LeanDojo&rsquo;s work shows that GPT4 cannot prove complex mathematical theorems such as Stirling&rsquo;s formula, even with sufficient prompt. The reason may be that there are too few theorem-proof data, and the most suitable method of LLM training has not been found, resulting in the lack of full use of LLM capabilities; It is also possible that the task of theorem proving itself has a richer complex and fine structure than language, and the violent aesthetics of LLM are not enough to conquer the arduous task of theorem proving. But while the task is daunting, it is not as mysterious as it was a few decades ago, and the mechanisms of proof and even reasoning have accumulated a wealth of knowledge, but there is still a lot of work to be done.</p>
<p>This section concludes with a response to some common questions:</p>
<blockquote>
<p>Because of Godel&rsquo;s incompleteness theorem (or for some other reason), a machine can never prove a mathematical theorem, because people are not bound by Godel&rsquo;s theorem, so theorem proving can only be done by people.</p>
</blockquote>
<p>Response: Godel actually has this view himself. But this view implies that man is an oracle Turing machine, that is, a Turing machine that can run for an infinite amount of time, and can travel through time to inform the present moment of the results of its operation after an infinite amount of time. According to the Church-Turing thesis, the Oracle is not a computational model that can be implemented in our universe. Corresponding to the task of proving theorems, this means that one can go through all the possibilities and find the right theorems to apply to without wasting time. It seems that human &ldquo;inspiration&rdquo; has a similar quality, but it actually means that one can find a proof without mathematical training, just by dreaming of a fairy. I prefer to believe that inspiration comes from some specific computational mechanism, even though it is currently only incompletely described by theories such as deep learning and reinforcement learning.</p>
<blockquote>
<p>But people can write axiom systems such as ZFC, they can also know that these axiom systems are not complete and then add axioms, they also invented the Turing machine and know that the Turing machine cannot solve the halting problem, people can set the foundation for mathematical proofs and Turing machines, and the machine itself has no way to set the foundation for itself.</p>
</blockquote>
<p>Response: This is to describe the level at which one can work on a metalinguistic level, that is, we study the properties of another language by virtue of language and only by virtue of language. A metalanguage is also a language, subject to the rules of computation, and presenting an axiomatic system and a halting problem is no different from other Turing-computable problems. Besides, people can&rsquo;t solve the shutdown problem. There is no reason to think that Turing machines cannot observe themselves, just as modern computers can also check their own memory for errors, it is simply engineering.</p>
<h1 id="present-and-future-of-dlatp">Present and future of DL+ATP<a hidden class="anchor" aria-hidden="true" href="#present-and-future-of-dlatp">#</a></h1>
<p>In December 2021, a paper titled &ldquo;Advancing mathematics by guiding human intuition with AI&rdquo; was published in Nature, It tells the story of Deepmind researchers who used traditional algorithms such as clustering to refine some laws in knot theory and representation theory, helping human mathematicians prove two new theorems. In June 2023, Tao evaluated how language models such as GPT4 helped him in his mathematical research, such as helping him quickly extract the content of other people&rsquo;s papers. AI is popping up in and out of mathematics, helping mathematicians with all sorts of work, but AI writing its own mathematical proofs seems a long way off. On the one hand, mathematics itself is very complex, and on the other hand, it is limited by the lack of data. Humans do write many papers and textbooks, accumulate a large amount of mathematical corpus, and LLMS do train on mathematical corpus such as Wikipedia. If you ask ChatGPT about math, it can answer a lot of valuable information, but interestingly, when you ask it to prove a theorem it has never seen before, it will output sentences that look like math but are full of errors, as if a writer who doesn&rsquo;t know math is trying to create lines for a mathematician character. Deep learning is good at capturing features, but it can&rsquo;t use propositions and verify the correctness of propositions, so it can only &ldquo;look&rdquo; like mathematics rather than actually implement mathematics. There is actually no machine that can verify the correctness of natural language mathematical proofs, and sometimes not even humans themselves, because every now and then there are papers that no human being can understand. At present, only formal languages such as Metamath, Isabella, Coq, and Lean can be used as the basic data for AI to understand mathematics, because they can be compiled and run to verify correctness.</p>
<p>In 1973, Andrzej Trybulec developed Mizar, the first formal language specifically for mathematics, as well as an associated mathematics library, in order to verify the correctness of his doctoral thesis (although fifty years later, we have not been able to realize his ideal). This theorem library is still under maintenance and has accumulated 1w+ definitions 65k+ theorems. There are still ATP algorithms tested on Mizar. In recent years, type theory languages such as Coq and Lean have built larger theorem libraries, which have become more and more popular, and test question libraries such as MiniF2F (F2F is short for formal to formal) have been established to measure the performance of ATP algorithms. MiniF2F contains 488 questions described in four formal languages (Coq, Lean, Isabelle, Hol light, but Hol light only contains 330 questions) and natural language, collected from various mathematical competitions, including many questions from the famous mathematical Odyssey IMO. For example, the question shown at the top of the article. The researchers also launched the IMO Grand Challenge, hoping to bring AI to the IMO gold medal.</p>
<p>(There is a hole to fill here, Mizar is very readable, very natural language like, and there is a recent rewritten version of Rust, I don&rsquo;t know why it hasn&rsquo;t caught on like Coq or Lean, wait for anyone who meets Mizar group to ask)
The original motivation for mathematicians to develop formal languages was to test proofs programmatically and mechanically, but perhaps the most profound change this tool brought to the study of mathematics was that it clearly divided the study of mathematics into two parts: the form, the strict statement that defines the theorem and the calculus of the proof; And ideas, that is, why the definition theorem is written the way it is, why a proposition is used in a proof. Ideas are the most mysterious and confusing things in mathematics, excellent ideas are often named genius, and even regarded as miracles, ordinary people can only admire, let alone use scientific means to study and reproduce these ideas. Category theory, for example, may be one of those attempts that belongs to mathematicians. Now we have the tools of cognitive science and the theory of artificial intelligence, and as the first section shows, the laws of mathematical ideas are being revealed step by step. In order to more clearly demonstrate the dichotomy between form and idea in mathematics, I have been thinking of an experimental project to write a complete mathematics textbook in a formal language. What can be written in formal language is all formalized, and there must be something left that must be written in natural language, and these are the parts of the idea. These natural languages can be a great source of research for ideas.</p>
<p>The most pressing problem facing DL+ATP research is that mathematical propositions expressed in formal language are still a drop in the ocean compared to the entire mathematical edifion of mankind. Fortunately, the development of LLM technology has led to &ldquo;pre-training&rdquo; and &ldquo;fine-tuning&rdquo; tools that can circumvent the lack of data to some extent. The idea is that many of the abilities and knowledge reflected in the data are universal, such as reasoning ability; The ability required for a particular task may be specialized, such as the specific syntax of a formal language. If the LLM has a general knowledge of the language before learning the domain-specific task, it is much better than the traditional method of directly letting the AI do the specific task from random initialization. Specifically, ATP, natural language mathematics, and formal language mathematics express the same mathematical meaning despite their differences in rigor and grammar, so the LLM pre-trained on a large number of human mathematical languages, learned some mathematical knowledge first, and then specialized in fine-tuning the scarce formal languages, should have a much better effect than only learning on formal language data. The classic work of DL+ATP, GPT-f, is to pretrain GPT3 on the natural language data set CommonCrawl, 23GB of Github code, 10GB of Arxiv Math papers, and 2GB of Math StackExchange forum articles. The motivation for training on code is that code also reflects human reasoning, much like proof. However, the subsequent improvement work of GPT-f HTPS believes that it is better to only pre-train on Arxiv, and who can say the configuration of optimized performance in engineering. HTPS has achieved a pass rate of 58.6% on the verification set and 41.0% on the test set of Lean language MiniF2F, which is the best result of pure proof search relying only on formal language. More information on evaluating data sets and algorithm performance can be found on the PaperWithCode page, but the information on this page is incomplete and has not been maintained for a long time.</p>
<p>Note 1: One of the drawbacks of fine-tuning is that it causes the LLM to focus only on domain-specific tasks and forget about general tasks, so it cannot be mathematically fine-tuned by tools such as ChatGPT to give it strong mathematical capabilities, which would make it lose other capabilities. Mathematical data sets were already part of ChatGPT&rsquo;s pre-training, although the pre-training data did not give it enough mathematical power.
Although LLMS can be pre-trained to learn mathematics beyond the available theorem proof data, the lack of theorem proof data is always a major hindrance to advancing the field. Readers who have the experience of using formal language will have a deep understanding that the process of mathematical proof in formal language is much more difficult than that of writing proof in natural language. Many details that we usually think are very ordinary and natural need to be completed, so the establishment of formal language theorem library needs a lot of human labor. If writing a formal language is such a hassle, why not let AI do it? The first attempt was made in 2018, followed by a report by Christian Szegedy in 2020, which formally raised the issue of autoformalization, the automatic translation of natural language mathematical propositions and proofs into formal language, like machine translation. The best performance of automated formalization tasks to date is also achieved by LLM, with a May 2022 test reporting that the best programming language model, Codex, could correctly translate 38 problems from natural language to Isabelle out of 150 problems extracted from the MATH dataset (which contains 12,500 natural language expressed math problems). It can be imagined that an algorithm that can translate two different mathematical languages well will inevitably involve an understanding of the nature of mathematical semantics, so the study of automatic formalization will also feed into the study of proof.</p>
<p>In terms of the concrete realization of the two problems, automatic formalization and ATP are also complementary tasks, because natural language proof is full of leaps, these natural omissions for humans can not be handled in the formal system, then ATP can be used to automatically complete. In turn, there is a clever practical idea that since formal language data is scarce, the search process for ATP can also be guided by natural language propositions. Representative work in this direction is the 2022 Draft, sketch, and prove: Guiding formal theorem provers with informal proofs (DSP), which uses Codex on Isabelle language to map natural language proofs into formal language proofs &ldquo;draft&rdquo;, that is, there are some leap-forward formal proofs. These hops are then automatically completed with Isabelle&rsquo;s symbolic autoprover Sledgehammer (Isabelle&rsquo;s symbolic autoprover is much stronger than Lean&rsquo;s). The natural language proofs could have been written by a human expert, who achieved 39.3% test set accuracy, or they could have been produced by another large model of natural language mathematical questions, Minerva, which achieved 38.9% test set accuracy. If Minerva is used, then both the natural language template and the formal language proof are produced by the algorithm itself, which can also be seen as the algorithm itself doing the ATP task. the best subsequent results from this method came from Decomposing the Enigma: Subgoal-based Demonstration Learning for Formal Theorem Proving, which is an improvement of DSP, also achieves 45.5% accuracy of the test set on Isabelle, which is also the best result on MiniF2F dataset. However, it is based on a different formal language from HTPS, and relies on natural language and cannot be directly indexed.</p>
<p>Note: One possible challenge to the DSP is that the Minerva training data contains mathematical text collected on the web page and the Arxiv text, which does not necessarily exclude the MiniF2F questions and is not &ldquo;clean&rdquo; enough, but the large language model can be regarded as a compression of the data, and generally cannot &ldquo;recite&rdquo; the solution, but can be regarded as a re-generated solution. However, Microsoft Copilot has done a job of reproducing irrelevant program comments, and the LLM&rsquo;s internal data processing principles are still harder to understand.
These results are far from ideal, but they have now translated some ATP tools that mathematicians may not think they can use. 22 years LEAN-GPTF as a proof tactic in Lean open test for a period of time, can prove some simple theorems, now closed test. HTPS has been integrated into Lean&rsquo;s VSCode editor extension, and when you write a proof you click a button to get the next sentence of a dozen AI recommendations, most of which are wrong, but some are right. VSCode&rsquo;s Copilot programming assistant can occasionally translate natural language math statements you write into Coq or Lean, and ChatGPT can occasionally write correct formal language proofs. The current situation looks bleak, but remember that this direction has only begun to develop in the last two or three years.</p>
<p>If you are willing to give a few more years of patience, what will DL+ATP bring to the world? The most immediate is to accelerate the development of formal mathematics. Introduction to Computer-Aided Proofs shows us a reliable and fair picture of mathematical research, and ATP can greatly reduce the cost of realizing this vision. We can feed a human math paper or a student&rsquo;s answer to a test question into an automated formal algorithm, and then have it generate code to verify correctness. Alternatively, you can translate the code into human language to make it easier to read, or extract concise ideas from complex proofs to help you understand them. We may not be able to make ATP system prove some big theorems for a long time, but it is very likely to assist in the process of human thinking about mathematics, for example, an important possibility is the auxiliary retrieval of mathematical content: An idea came to my mind, and I wondered if anyone else had come up with a similar idea, maybe there was a precise theorem that expressed the idea in a way that traditional keyword matching searches could not find, but AI could understand the idea at an abstract semantic level to find relevant data.</p>
<p>Finally, a little sci-fi fantasy. If one day mathematical AI can prove the Riemann conjecture, it is not difficult to imagine that AI can also solve scientific problems such as room-temperature superconductivity, controlled nuclear fusion, eliminate various diseases, and even solve all social production problems. Mathematics represents the peak of human abstract reasoning ability, and when AI also has abstract reasoning ability, it may be able to become the complete general artificial intelligence. What will society look like then?</p>
<h1 id="learning-map">Learning Map<a hidden class="anchor" aria-hidden="true" href="#learning-map">#</a></h1>
<p>If you are an enthusiast who wants to learn more about this field, with the goal of generally reading the leading papers in this direction, then you will need some introduction to deep learning and a preliminary understanding of LLM, at least familiar with the principles of the encoder-decoder architecture. It is more important to have experience with at least one formal language, and I recommend Lean here because modern DL+ATP is increasingly using Lean.</p>
<p>If you want to pursue research in this field&hellip;&hellip; Dissuade warning! You&rsquo;re dealing with the most complex and comprehensive field in AI and the second most distant from money after people who do theory. (If any friend is not satisfied, please contact me to help ATP improve the ranking, thank x in advance)</p>
<p>DSP instructor Albert Jiang pointed out that DL4Math people have a lot of money. HTPS writers Guillaume, Tim, Thibault, Marie-Anne went to mistral ai, Google&rsquo;s Yuhuai Wu, Christian went to xai, jesse founded morph, stanislas founded dust, markus is starting a business. But I refuse to admit it until someone gives me money (x).
The first is the need for more comprehensive knowledge of deep learning and reinforcement learning. LLM Needless to say, the main paradigm today is based on LLM, but CV knowledge is also helpful, because geometric propositions and the geometric intuitions of some propositions also need to be taken into account; Graph-based approaches have potential, so an understanding of GNN-related approaches can also be helpful; The latest work even uses the popular Diffusion method. In addition to these modern techniques, as seen before, DL and RL are still developed under the framework built in the pre-deep learning era, so it is important to understand the traditional methods. Outside of AI, you&rsquo;ll be working on the basis of a type theory language, so you&rsquo;ll need to know some &ldquo;common sense&rdquo;, such as mathematical logic and various type theories, functional programming, category theory, and so on. Some subproblems with a strong symbolic tradition will emphasize this knowledge more, but work like HTPS will use it as background knowledge. Overall, the road ahead for ATP is not clear, and the accumulated knowledge in this field is not deep enough to get started quickly, but researchers must have a fairly wide range of knowledge to find the next breakthrough, although they may not be directly applicable, but can provide more insight or at least not cause you to make a simple mistake.</p>
<p>The main event in the field of DL+ATP is the Artificial Intelligence and Theorem Proving conference AITP, and the Intelligent Computer Mathematics Conference CICM is also noteworthy. In addition, the MATH-AI workshop has been held in ICLR2021 and NeurIPS2022 for two sessions, and the third session will be held in NeurIPS2023 at the end of this year (2023.12.15/16). Welcome to your attention. At the NeurIPS conference, Albert Jiang, Kaiyu Yang and Emily First will also provide tutorial on machine learning theorem proving. Welcome to join us! In addition to conferences, if you&rsquo;re in the Lean zulip community, check out stream Machine-Learning-for-Theorem Proving.</p>
<p>Finally, post a list of papers for further study.</p>
<p>A survey of deep learning for mathematical reasoning (2022).  An overview is always the best place to start.</p>
<p>Holophrasm: a neural automated theorem prover for higher-order logic (2016). DL+ATP started with quite advanced ideas, and there was even no transformer at that time. Unfortunately, the author has retired now.</p>
<p>Generative language modeling for automated theorem proving (2020).  The famous GPT-f OpenAI is in with a lot of money.</p>
<p>Proof artifact co-training for theorem proving with language models (2021).  Another classic work PACT, which uses a new training method and is more robust than GPT-f, is the main control group for future work.</p>
<p>Formal mathematics statement curriculum learning (2022).  The highlight is the use of curriculum learning, which is stronger than PACT.</p>
<p>Hypertree proof search for neural theorem proving (2022).  The strongest HTPS, GPT-f scale +Holophrasm search algorithm. OpenAI&rsquo;s big money turned around to hit ChatGPT, Meta took over OpenAI, but it&rsquo;s not open source.</p>
<p>DT-Solver: Automated Theorem Proving with Dynamic-Tree Sampling Guided by Proof-level Value Function (2023).  The latest achievement, produced by Sun Yat-sen University, Peking University and Huawei. Slightly better than PACT.</p>
<p>LeanDojo: Theorem Proving with Retrieval-Augmented Language Models (2023).  I do not want to list it, but this article has been on the public number for a long time, in fact, the main work is to establish a data set. The structure of the model proposed in the paper is simple, and the Reprover model feels like a matching validation of the data set.</p>
<p>There are also Skip-tree Training, TacticToe, LISA and other equally wonderful jobs.</p>
<p>The above is the most basic ATP work using pure formal language, and there are more natural language components below.</p>
<p>Thor:  Wielding hammers to integrate language models and automated theorem provers (2022) This is Thor, Go beyond PACT by having a language model that is not fine-tuned on a formal language dataset work with the formal language editor&rsquo;s automatic search function.</p>
<p>Solving quantitative reasoning problems with language models (2022).  This is Minerva, natural language math, and even physics and chemistry.</p>
<p>Draft, sketch, and prove: Guiding formal theorem provers with informal proofs (2022).  This is DSP, using natural language proofs to guide the standard work of formal language proofs, going beyond Thor.</p>
<p>Decomposing the Enigma: Subgoal-based Demonstration Learning for Formal Theorem Proving (2023).  in this paper, the Subgoal method of reinforcement learning is introduced, and the optimal result on MiniF2F is achieved by using Diffusion on the graph to optimize in context learning.</p>
<p>Autoformalization with large language models (2022).  This article is enough for the direction of pure breed automatic formalization, and for early research you can check the Related Work section of this article.</p>
<p>Evaluating Language Models for Mathematics through Interactions (2023).  A detailed survey report on the mathematical ability of ChatGPT class large language models.</p>
<p>This list is extensive, interested friends can follow the guide in the above articles. There may be a lot of important work I can&rsquo;t think of right now, please add in the comments section.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://subfish-zhou.github.io/tags/dl/">DL</a></li>
      <li><a href="https://subfish-zhou.github.io/tags/lean/">Lean</a></li>
      <li><a href="https://subfish-zhou.github.io/tags/atp/">ATP</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://subfish-zhou.github.io/posts/autoformalization/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Automatic formalization of mathematics: a path to automatic reasoning</span>
  </a>
</nav>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on twitter"
        href="https://twitter.com/intent/tweet/?text=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving&amp;url=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f&amp;hashtags=DL%2cLean%2cATP">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f&amp;title=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving&amp;summary=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving&amp;source=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f&title=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on whatsapp"
        href="https://api.whatsapp.com/send?text=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving%20-%20https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Introduction of Deep Learning for Automatic Theorem Proving on telegram"
        href="https://telegram.me/share/url?text=Introduction%20of%20Deep%20Learning%20for%20Automatic%20Theorem%20Proving&amp;url=https%3a%2f%2fsubfish-zhou.github.io%2fposts%2fdlatp%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <script type="text/javascript"
        async
        src="https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$'], ['\[\[','\]\]']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
});

MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<style>
code.has-jax {
    font: inherit;
    font-size: 100%;
    background: inherit;
    border: inherit;
    color: #515151;
}
</style>
<footer class="footer">
    <span>&copy; 2023 <a href="https://subfish-zhou.github.io/">Subfish&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
